#Right now, there's no error handling in this code. Also, it only works for scalar moduli. 


#First, this function constructs the Hilbert class field (HCF) for the imaginary quadratic 
#field K generated by sqrt(-a). Second, it constructs the ray class field (RCF) for the modulus b. 
#Note that a and b need to be positive integers and b is the modulus for the RCF. It also returns
#the elliptic curve E used in the construction of the HCF and the largest irreducible factor of its
#b-division polynomial. These additional objects are needed for desired example computations. 

def HCF_and_RCFconstructor(a, b):
	x = polygens(QQ, 'x')
	R.<x> = PolynomialRing(QQ)
	f = x^2 + a
	K.<y> = NumberField(f)
	hilbert_polynomial = K.hilbert_class_polynomial()
	HCF.<z> = K.extension(hilbert_polynomial)
	hilbert_polynomial = hilbert_polynomial.change_ring(HCF)
	chosen_j_invariant = hilbert_polynomial.roots()[-1][0]
	E=EllipticCurve(j=HCF(chosen_j_invariant))
	divpoly = E.division_polynomial(b)

	#Sage returns the factors of the division polynomial in ascending order based on degree.
	#Since we know that E[b] has cyclic O-module structure (O is maximal here), we know that 
	#the roots of the largest-degree irreducible factor of the division polynomial are the 
	#O-module generators for E[b] and hence that the extension of the HCF given by this polynomial
	#is the RCF for the modulus b.
	
	RCF.<a> = HCF.extension(divpoly.factor()[-1][0])
	return(HCF, RCF, E, divpoly.factor()[-1][0])

#This functions determines the subfields of the given ray class field (RCF) that contain the given 
#Hilbert class field. These two fields should be related, i.e. the RCF should contain the HCF. Everything
#is done in the most naive way, so it's probably very inefficient in general. Also, it does not determine
#the full subfield lattice structure, though it's probably not hard to naively implement this as well.

def HCF_to_RCF_fields(RCF, HCF):

	#Find all the subfields of the RCF
	
	G = RCF.absolute_field(names='t').galois_group()
	subfields_of_RCF = []
	for i in G.subgroups():
		subfields_of_RCF.append(i.fixed_field()[0])

	#Find which subfields contain the HCF: looping through the subfields of the RCF,
	#check to see if HCF embeds into the given subfield via the embeddings() method
	
	HCF_to_RCF_intermediate_fields = []

	for i in range(0,len(subfields_of_RCF)):
		if len(HCF.embeddings(subfields_of_RCF[i])) > 0:
			HCF_to_RCF_intermediate_fields.append(subfields_of_RCF[i])
	
	return HCF_to_RCF_intermediate_fields

#An example with K = Q(sqrt(-5)) and modulus (6). I'm making extensive use of the fact that we know Gal(RCF/HCF) is the Klein 4-group.
#In particular, it follows from this that the only trace sums we need to consider are those that consist of a fixed root of RCFminpoly 
#summed with one of the other 3 roots. 

#Getting all the necessary initial data

example_data = HCF_and_RCFconstructor(5, 6)
HCF = example_data[0]; RCF = example_data[1]; RCFminpoly = example_data[3]
intermediate_fields = HCF_to_RCF_fields(HCF, RCF)

#Determining the trace sums and constructing the associated extensions of HCF

RCFminpoly = RCFminpoly.change_ring(RCF)
roots = []
for i in RCFminpoly.roots():
	roots.append(i[0])

trace_sums = []
for i in range(1, len(roots)):
	trace_sums.append(roots[0]+roots[i])

trace_sums_minpolys = []
for i in trace_sums:
	f = i.minpoly()
	trace_sums_minpolys.append(f)

trace_sums_fields = []
for i in trace_sums_minpolys:
	L.<t> = HCF.extension(i)
	trace_sums_fields.append(L)


#Checking to see if the extensions of the HCF given by the trace sums are 
#isomorphic to nontrivial extensions. intermediate_fields lists the subfields of RCF 
#containing HCF in descending order of degree, so by starting at j = 1 in the inner loop 
#we're just not checking for embeddings into RCF. We can say that the remaining homs actually
#are isomorphisms because we know the subfield lattice structure already. 

for i in range(0, len(trace_sums_fields)):
	for j in range(1, len(intermediate_fields)):
		if len(Hom(trace_sums_fields[i], intermediate_fields[j]).list()) > 0:
			print('Trace Sum Field ' + str(i) + ' is isomorphic to intermediate field '+
 str(j))


